{"meta":{"title":"初始设定","subtitle":"","description":"","author":"Ridder","url":"https://Riddddder.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-10-28T10:01:47.478Z","comments":true,"path":"404.html","permalink":"https://riddddder.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2024-10-28T10:00:25.000Z","updated":"2024-10-30T17:02:46.821Z","comments":true,"path":"about/index.html","permalink":"https://riddddder.github.io/about/index.html","excerpt":"","text":"2021年广州毕业，目前在珠海工作，从事前端开发； 技术框架主要是vue、element-ui、uniapp、vant等； 看好flutter，尝试使用flutter的getx开发； 后端沉淀中，熟悉Java、MySQL、Redis，框架SpringBoot、Mybatis-Plus等； 希望有朝一日能做出自己的作品， 初始设定，大概意思就是望自己永远保持初心！"},{"title":"schedule","date":"2024-10-29T10:58:02.160Z","updated":"2024-10-29T10:58:02.160Z","comments":true,"path":"schedule/index.html","permalink":"https://riddddder.github.io/schedule/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-10-29T10:57:30.569Z","updated":"2024-10-29T10:57:30.569Z","comments":true,"path":"categories/index.html","permalink":"https://riddddder.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-10-29T10:57:10.828Z","updated":"2024-10-29T10:57:10.828Z","comments":true,"path":"tags/index.html","permalink":"https://riddddder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"（已解决）vue-element-plus-admin打包报错","slug":"Node内存问题","date":"2024-10-24T10:51:00.000Z","updated":"2024-10-30T17:05:28.076Z","comments":true,"path":"2024/10/24/Node内存问题/","permalink":"https://riddddder.github.io/2024/10/24/Node%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 问题描述 在一次使用 vue-element-plus-admin 打包时，出现如下报错: 1FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript # 问题原因 node 内存泄漏耗尽，JavaScript 堆内存不足。因为 Node 是基于 V8 引擎，在 Node 中通过 JavaScript 使用内存时只能使用部分内存。 # 解决方法 安装依赖工具 1npm install increase-memory-limit --save 1npm install cross-env --save 修改 package.json 如下:[LIMIT 大小自己设置] 123&quot;scripts&quot;: &#123; &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=2048 increase-memory-limit&quot; &#125;, 最后执行就可以打包啦 1npm run fix-memory-limit","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"}]},{"title":"怎么处理浏览器兼容性","slug":"浏览器兼容性","date":"2023-01-29T02:54:42.000Z","updated":"2024-10-31T15:55:20.329Z","comments":true,"path":"2023/01/29/浏览器兼容性/","permalink":"https://riddddder.github.io/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/","excerpt":"","text":"1面试官：说说你在工作中是怎么处理浏览器兼容性 这个问题，是面试官想知道你的学习广度，你的知识体系是否全面。 其实针对前端三部分（HTML、CSS、JavaScript），考虑浏览器兼容性只有 CSS 和 JavaScript；因为针对 HTML，在开发中就常用的几个标签，浏览器从头到脚都认识，还需要兼容吗？ 针对 CSS 的兼容性，你只需要有添加浏览器前缀，变量转换等意识即可 针对 JavaScript 的兼容性，你只需要有新旧语法兼容和新旧函数兼容意识即可。 只需要有这两个意识就行，实现也已经不需要从头到尾的写，而是借助工具即可 # CSS 兼容性 # 浏览器前缀 浏览器前缀是浏览器厂商为了实验性 CSS 属性而添加的标识符，它们通常用于 CSS 规则的前面。以下是一些常见的浏览器前缀： webkit-：用于 Chrome、Safari（WebKit 内核） moz-：用于 Firefox（Gecko 内核） o-：用于 Opera（Presto 内核，已逐渐淘汰） ms-：用于 Internet Explorer（Trident 内核） 例如，如果你想要使用 CSS 的 transform 属性，可能需要添加所有浏览器的前缀： 1234567.element &#123; -webkit-transform: rotate(45deg); /* Chrome, Safari */ -moz-transform: rotate(45deg); /* Firefox */ -ms-transform: rotate(45deg); /* IE */ -o-transform: rotate(45deg); /* Opera */ transform: rotate(45deg); /* 标准语法 */&#125; 为了简化这个过程，可以使用一些工具自动添加浏览器前缀： Autoprefixer：一个后处理工具，可以根据 Can I Use 的数据自动添加所需的浏览器前缀。 PostCSS：一个使用 JavaScript 的插件系统，可以处理 CSS 的转换，包括添加前缀。 # 变量转换 CSS 变量的兼容性问题较少，因为它们已经成为 CSS 的一个标准部分。 但是，为了确保在不支持 CSS 变量的旧浏览器中也能正常显示，可以使用以下方法： 回退值：在 var () 函数中提供回退值。 PostCSS：使用 PostCSS 插件将 CSS 变量转换为静态值。 # JavaScript 的兼容性 再来说说 JavaScript 的兼容性吧，针对新旧语法的兼容可以作转换，而针对新旧函数的兼容就需要加补丁。 # babel 其实在开发过程中，最常见的就是跟 JavaScript 打交道，也会真实感受到 JavaScript 存在新的语法，那么这些新的语法就需要转化，才能被浏览器认识。那么这时候就可以借助一个工具 babel。用于专门来降低 JavaScript 语法的。 babel 就是一个编译器，把一段源代码转化成另外一段新代码，新代码就能被浏览器识别。对了，既然 babel 是工具（postcss 也是一样），能单独使用，也能够配合使用。而我们在项目开发过程中，都会使用构建工具（比如说 webpack），但是又想使用 babel 工具，那么这时候就需要一个桥梁，而 webpack 中的桥梁就是 babel-loader，具体怎么操作你回去研究一下。 # polyfill 手动打补丁 根据覆盖率自动打补丁 根据浏览器特性，动态打补丁 JS 代码能够被转化减低，适配了市场占比的浏览器，是不是就已经完成了呢？当然没有。 在 ES6 中出现了 Promise，fetch，以及数组和字符串新的方法，babel 会进行转化吗？会转化成什么呢？肯定不会被转化撒，因为它们都是函数调用，对于 babel 来说就是一个普通的函数调用，只是找不到函数的实现体而已，只是会报错而已。 那么这里也就需要兼容一下，因为新版本的浏览器是认识的，老版本的浏览器是不认识的，那么这里就需要为了兼容了老版浏览器，新部署一个 JS 文件（类似补丁），里面存放了各个函数（promise, fetch）体的实现代码。然后浏览器就能够正常的识别了。 # 参考文章 掘金 - 面试官：说说你在工作中是怎么处理浏览器兼容性","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"前端笔记（四）：localStorage和sessionStorage","slug":"localStorage和sessionStorage","date":"2022-01-10T04:51:59.000Z","updated":"2024-10-31T06:55:01.451Z","comments":true,"path":"2022/01/10/localStorage和sessionStorage/","permalink":"https://riddddder.github.io/2022/01/10/localStorage%E5%92%8CsessionStorage/","excerpt":"","text":"# 基本概念 localStorage 和 sessionStorage 都是 Web Storage API 的一部分，用于在客户端存储数据。它们都是键值对存储，可以存储字符串数据，也可以存储对象数据。 # 区别 localStorage 和 sessionStorage 的主要区别在于数据的生命周期。localStorage 的数据会一直存在，直到手动删除，而 sessionStorage 的数据在页面会话结束时会被清除。 # 作用域不同 sessionStorage 的作用域限定在当前会话（当前浏览器标签页或窗口）。 localStorage 的作用域是永久的，数据在不同会话（遵循同源策略）之间共享。 # 生命周期不同 sessionStorage 的数据在会话结束时被清除，即当用户关闭浏览器标签页或窗口时，sessionStorage 中的数据会被删除。 localStorage 的数据是持久化的，除非被显式清除，否则会一直保存在客户端。 # 存储大小不同 sessionStorage 的存储容量通常比 localStorage 小。一般来说，sessionStorage 的容量限制在 5MB 左右。 localStorage 的容量限制通常在 5MB 到 10MB 之间，不同浏览器可能会有所不同。 # 数据共享不同 sessionStorage 的数据在同一个浏览器标签页或窗口中共享，但不会跨标签页或窗口共享。 localStorage 的数据在同一个域名下的所有标签页和窗口中共享。 # 使用场景 sessionStorage 适用于存储需要在同一会话中共享的数据，例如用户的登录状态、表单数据等。当用户关闭浏览器标签页或窗口时，这些数据会被自动清除。 localStorage 适用于存储需要在多个会话中共享的数据，例如用户的偏好设置、购物车数据等。这些数据会一直保存在客户端，直到被显式清除。 # 使用方法 # localStorage 1234567891011// 存储数据localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);// 获取数据var value = localStorage.getItem(&#x27;key&#x27;);// 删除数据localStorage.removeItem(&#x27;key&#x27;);// 清空所有数据localStorage.clear(); # sessionStorage 1234567891011// 存储数据sessionStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);// 获取数据var value = sessionStorage.getItem(&#x27;key&#x27;);// 删除数据sessionStorage.removeItem(&#x27;key&#x27;);// 清空所有数据sessionStorage.clear(); # 注意事项 localStorage 和 sessionStorage 的数据存储遵循同源策略，即只有在相同域名、相同协议和相同端口下的页面才能访问这些数据。 localStorage 和 sessionStorage 的数据存储是同步的，即调用 setItem 、 getItem 、 removeItem 和 clear 方法会立即生效，不会阻塞页面的渲染。因此，在调用这些方法时，需要注意不要在关键路径上使用它们，以免影响页面的性能。 localStorage 和 sessionStorage 的数据存储是字符串类型的，如果需要存储非字符串类型的数据，可以使用 JSON.stringify 和 JSON.parse 方法进行序列化和反序列化。 localStorage 和 sessionStorage 的数据存储是持久化的，即数据不会在页面关闭后自动清除。如果需要清除数据，可以使用 removeItem 或 clear 方法。 localStorage 和 sessionStorage 的数据存储大小有限制，一般为 5MB 左右，不同浏览器可能会有所不同。如果需要存储大量数据，可以考虑使用其他存储方式，如 IndexedDB。 localStorage 和 sessionStorage 的数据存储是安全的，即数据不会被第三方脚本访问。但是，如果页面中存在 XSS 攻击，攻击者可以通过注入恶意脚本访问这些数据。因此，在使用 localStorage 和 sessionStorage 时，需要注意不要存储敏感数据，以免造成安全风险。 localStorage 和 sessionStorage 的数据存储是可被浏览器清除的，如用户手动清除浏览器缓存、浏览器崩溃等。因此，在使用 localStorage 和 sessionStorage 时，需要注意数据的持久化和安全性。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端笔记（二）:ES6学习笔记","slug":"ES6学习笔记","date":"2021-07-19T04:32:04.000Z","updated":"2024-10-31T06:56:40.844Z","comments":true,"path":"2021/07/19/ES6学习笔记/","permalink":"https://riddddder.github.io/2021/07/19/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"# ES6 学习笔记 # let 和 const # symbol Symbol 是 ES6 中引入的一种新的基本数据类型，用于表示一个独一无二的值，不能与其他数据类型进行运算。它是 JavaScript 中的第七种数据类型 1234const a = Symbol();console.log(a); //Symbol()const a = new Symbol();//报错，Symbol is not a constructor，因为Symbol是基本数据类型，而不是对象，不能 new 。 # class # 字符串新特性 # 模板字符串 使用反引号 `` 和 ${} 来引用变量 # 字符串新方法 includes () 判断字符串是否包含参数字符串，返回 boolean 值。 startsWith () /endsWith ()，判断字符串是否以参数字符串开头或结尾。返回 boolean 值。这两个方法可以有第二个参数，一个数字，表示开始查找的位置 repeat () 方法按指定次数返回一个新的字符串。 1console.log(&quot;hello&quot;.repeat(2)//&quot;hellohello&quot; padStart ()/padEnd ()，用参数字符串按给定长度从前面或后面补全字符串，返回新字符串。 # 数组新方法 Array.from () 是内置对象 Array 的方法，实例数组不能调用 includes () 参数：数值 -------- 返回值：true/false map ()、filter () 参数：函数 -------- 返回值：数组 forEach () 参数：函数 -------- 返回值：undefined find () 参数：函数 -------- 返回值：数值 some ()、every () 参数：函数 -------- 返回值：true/false # object 新方法 Object.is() Object.assign() Object.keys() Object.values() Object.entries() # 对象扩展符 # 拷贝 12345let obj = &#123;name: &quot;xiaoming&quot;, age: 18&#125;;let obj1 = &#123;...obj&#125;;console.log(obj1 === obj);//falseobj1.name = &quot;xiaohong&quot;;console.log(obj.name);//xiaoming # 合并 1234let obj = &#123;name: &quot;xiaoming&quot;, age: 18&#125;;let obj1 = &#123;sex: &quot;male&quot;&#125;;let obj2 = &#123;...obj, ...obj1&#125;;console.log(obj2);//&#123;name: &quot;xiaoming&quot;, age: 18, sex: &quot;male&quot;&#125; # 箭头函数 箭头函数实现了一种更加简洁的书写方式。箭头函数内部没有 arguments，也没有 prototype 属性，所以不能用 new 关键字调用箭头函数 箭头函数和普通函数最大的区别在于其内部 this 永远指向其父级对象的 this。(重点) # 解构赋值 - 解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 字符串、以及 ES6 新增的 Map 和 Set 都可以使用解构表达式 1234567let [a, b, c, d, e] = &quot;Hello&quot;;// 字符串解构let &#123; name, age, sex &#125; = &#123; name: &quot;xiaoming&quot;, age: 18, sex: &quot;male&quot; &#125;;// 对象解构let [a,b,c] = [1,2,3]; // 数组解构let [a,..b] = [1,2,3]; //...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给bconsole.log(a,b);//1,[2,3]let [foo, [[bar], baz]] = [1, [[2], 3]]; // 嵌套数组解构 # Promise # async/await 语法糖 # 模块化 # 新增对象 # Set 可以理解为后端的 Set 集合对象 (ArrayList) Set 对象和 Map 对象类似，但它存储不是键值对。类似数组，但它的每个元素都是唯一的。 WeakSet 1234let set = new Set([1,2,3]);set.add(4);set.delete(1);set.has(2); // true # Map Map 对象用于保存键值对，任何值 JavaScript 支持的值都可以作为一个键（key）或者一个值（value）。与对象不同的是： object 的键只能是字符串或 ES6 的 symbol 值，而 Map 可以是任何值。 Map 对象有一个 size 属性，存储了键值对的个数，而 object 对象没有类似属性。 WeakMap 12345678910let map = new Map();map.set(&quot;name&quot;, &quot;xiaoming&quot;);map.set(&quot;age&quot;, 18);map.set(&quot;sex&quot;, &quot;male&quot;);map.get(&quot;name&quot;); // &quot;xiaoming&quot;map.has(&quot;name&quot;); // truemap.delete(&quot;name&quot;); // truemap.has(&quot;name&quot;); // falseconsole.log(map.size); // 3map.clear(); // 清空map # for…of for…of 循环是 ES6 引入的一种新的循环机制，用于遍历可迭代对象（如数组、字符串等）的元素。在字符串上使用 for…of 可以方便地遍历字符串中的每个字符。 1234et str = &quot;Hello&quot;;for (let char of str) &#123; console.log(char);&#125; # for…in (阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版)[https://www.bookstack.cn/read/es6-3rd/sidebar.md]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端笔记（一）：javascript基础","slug":"Javascript面试","date":"2021-07-10T09:51:56.000Z","updated":"2024-10-31T15:58:08.064Z","comments":true,"path":"2021/07/10/Javascript面试/","permalink":"https://riddddder.github.io/2021/07/10/Javascript%E9%9D%A2%E8%AF%95/","excerpt":"","text":"# javascript 笔记 # js 的数据类型 基本数据类型：Number、String、Boolean、Null、Undefined、Object、（Symbol、bigInt） 引用数据类型：Array、Function、Object Null 只有一个值，是 null。不存在的对象。 Undefined 只有一个值，是 undefined。没有初始化。undefined 是从 null 中派生出来的。 简单理解就是：undefined 是没有定义的，null 是定义了但是为空。 Symbol 类型的对象永远不相等，即便创建的时候传入相同的值。因此，可以用解决属性名冲突的问题（适用于多少编码），做为标记。 # var，let，const 的区别 var 全局变量，能重复声明 let 局部变量，代码块内有效，不能重复声明 const 常量，一旦声明，常量的值就不能改变，就必须立即初始化，不能留到以后赋值 # es6 有哪些新特性 let const 模板字符串 扩展运算符 解构赋值 箭头函数 Promise、async/await 数组新方法：map、filter、reduce、some、every # 检测数组类型的方法 instanceof of， 例：arr instanceof Array constructor , 例：arr.constructor === Array Array.isArray(arr) call 方法，例：Object.prototype.toString.call (arr) === ‘[object Array]’ # 数组的方法 改变原数组：push、pop、shift、unshift、sort、splice、reverse 不改变原属组：concat、join、map、forEach、filter、slice # 字符串方法 1 charAt (x) 返回字符串中 x 字符的位置，下标从 0 开始 2 charCodeAt (x) 返回字符串中 x 位置处字符的 unicode 值 3 concat () 用于连接两个或多个字符串 4 fromCharcode () 将一组 Unicode 码转换为字符 5 indexOf (substr, [start]) 返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。 6 lastIndexOf (substr, [start]) 返回指定文本在字符串中最后一次出现的索引，如果未找到，则返回 - 1。 7 match (regexp) 根据正则表达式在字符串中搜索匹配项。如果没有找到匹配项，则返回 null。 8 replace (regexp/substr, replacetext) 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 9 search (regexp) 检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，如果找到，返回与 regexp 相匹配的子串的起始位置，否则返回 -1。 10 slice (start, [end]) 裁取字符串的某个部分，返回一个新的字符串。包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符 11 split (delimiter, [limit]) split () 方法用于把一个字符串分割成字符串数组，返回一个字符串数组，返回的数组中的字串不包括 delimiter 自身。 可选的 “limit” 是一个整数，允许各位指定要返回的最大数组的元素个数。 12 substr (start, [length]) 在字符串中抽取从 start 下标开始的指定数目的字符。返回一个新的字符串，包含从 start（包括 start 所指的字符） 处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到该字符串的结尾的字符。 13 substring (start,stop) 用于提取字符串中介于两个指定下标之间的字符 14 toLowerCase () 把字符串转换为小写。 15 toUpperCase () 把字符串转换为大写。 16 includes () 检查字符串是否包含指定的字符串或字符。 17 endsWith () 检查字符串是否以指定的字符串或字符结束。 18 repeat () 将字符串复制指定次数。 19 valueOf () 返回一个 String 对象的原始值（primitive value），该值等同于 String.prototype.toString ()。 20 trim () 从一个字符串的两端删除空白字符。 # 匿名函数和箭头函数 function 后并没有给函数命名，而是把整个函数直接赋值给变量 abs，调用时通过 abs (9) 来调用此函数。 箭头函数的定义用的就是一个箭头。箭头函数表面上相当于匿名函数，并且简化了函数定义。 当箭头函数只包含一个表达式时，它连 {…} 和 return 都省掉了。 # 水平垂直居中的方法 # 定位法 定位，position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto; 定位，position: absolute; top: 50%; left: 50%; transform: translate (-50%, -50%); 定位，(已知子元素宽高) width:100px;height:100px;position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; # flex 布局 diplay: flex; justify-content: center; align-items: center; # grid 网格布局 diplay: grid; align-items:center;justify-content: center; # table 表格布局 设置父元素为 display:table-cell，子元素设置 display: inline-block。利用 vertical 和 text-align 可以让所有的行内块级元素水平垂直居中 # 继承的方式 原型继承：不能传参 组合继承： 调用了两次父类的构造函数，不共享父类引用属性 寄生组合继承： ES6 的 extend：子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话必须是 super # 深拷贝和浅拷贝 # 深拷贝 JSON.parse(JSON.stringify(obj)) 递归拷贝 1234567891011121314151617function deepCopy(obj) &#123; // 判断是否为null或者不是对象 if (obj &amp;&amp; typeof obj !== &#x27;object&#x27;) &#123; return obj; &#125; // 判断是对象还是数组 let copy = Array.isArray(obj) ? [] : &#123;&#125;; // 遍历 for (le t key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 递归 copy[key] = deepCopy(obj[key]); &#125; &#125; return copy;&#125; # 浅拷贝 let obj1 = Object.assign({}, obj) 扩展运算符 1let obj1 = &#123; ...obj &#125; Array.prototype.slice() Array.prototype.concat()","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"hexo主题-NexT主题食用","slug":"hexo主题-NexT主题食用","date":"2021-06-30T11:00:03.000Z","updated":"2024-10-31T16:07:52.527Z","comments":true,"path":"2021/06/30/hexo主题-NexT主题食用/","permalink":"https://riddddder.github.io/2021/06/30/hexo%E4%B8%BB%E9%A2%98-NexT%E4%B8%BB%E9%A2%98%E9%A3%9F%E7%94%A8/","excerpt":"","text":"NexT 主题是一个非常简洁的主题，非常适合新手使用。下面我将介绍如何安装和使用 NexT 主题： # 安装主题 这一步直接在博客项目文件中执行，安装好的主题会在 ./themes/next 中 1git clone https://github.com/next-theme/hexo-theme-next ./themes/next 在_config.yml 中设置 1theme: next # NexT 的配置 打开 ./themes/next/_config.yml 搜索 menu 可配置菜单，将需要的菜单注释去掉，并添加菜单项，如： 123456789menu: home: / || fa fa-home tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive # schedule: /schedule/ || fa fa-calendar # sitemap: /sitemap.xml || fa fa-sitemap about: /about/ || fa fa-user # commonweal: /404/ || fa fa-heartbeat 去掉之后，在浏览器依旧是看不到内容的，需要创建对应页面。 123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot;hexo new page &quot;about&quot; 并且需要在创建好的页面中添加 type 字段，如： 12title: tagstype: &quot;tags&quot; 12title: categoriestype: &quot;categories&quot; 关于页面可以写点文字介绍自己。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2021-06-29T14:21:44.000Z","updated":"2024-10-31T16:03:15.034Z","comments":true,"path":"2021/06/29/hello-hexo/","permalink":"https://riddddder.github.io/2021/06/29/hello-hexo/","excerpt":"","text":"# hexo 介绍 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 # 安装前准备 Node.js 12.0 以上版本，下载 git 下载 如果工作需要装了 node 可以安装 nvm 管理多版本 node。 # 安装 安装好 node 后，执行下列命令就可以完成 blog 文件夹初始化（blog 为任意空文件夹名称） 1234npm install -g hexo-clihexo init blogcd blognpm install 然后再执行 1hexo s 就可以看到控制台输出 localhost:4000 就可以在本地浏览器访问啦 # 主题 shoka 在 blog 文件夹 1git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 在_config.yml 中设置 1theme: shoka # 主题 next 在 blog 文件夹 1git clone https://github.com/next-theme/hexo-theme-next ./themes/next 在_config.yml 中设置 1theme: next # 插件 hexo-admin 1$npm install hexo-admin -s 安装好后 locahost:4000/admin 访问 # 文章 # 新建草稿 草稿是没发布是不会显示的 1hexo new draft 草稿文件名 # 新建文章 -p, --path: 自定义新文章的路径 -r, --replace: 如果存在同名文章，将其替换 -s, --slug: 文章的 Slug，作为新文章的文件名和发布后的 URL 1hexo new 文章标题 # 发布 # 发布草稿 1hexo publish 文章文件名 # 清除文章缓存 发布前需要清除存在的缓存 db.json 和 public 文件夹下的静态文件。 1hexo clean # 生成静态文件 1hexo g # 部署 部署到 git 上，需要先配置 git 1hexo d # 参考资料 [hexo 官网] https://hexo.io/zh-cn/docs/ [front-matter] https://hexo.io/zh-cn/docs/front-matter.html [shoka-github] https://github.com/amehime/hexo-theme-shoka?tab=readme-ov-file [shoka 文档] https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/ [next 官网] https://theme-next.iissnan.com/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"},{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]}