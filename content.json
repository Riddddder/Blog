{"meta":{"title":"初始设定","subtitle":"","description":"","author":"Ridder","url":"https://Riddddder.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-10-28T10:01:47.478Z","comments":true,"path":"404.html","permalink":"https://riddddder.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2024-10-29T10:57:30.569Z","updated":"2024-10-29T10:57:30.569Z","comments":true,"path":"categories/index.html","permalink":"https://riddddder.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2024-11-20T03:25:24.794Z","updated":"2024-11-20T03:25:24.794Z","comments":true,"path":"about/index.html","permalink":"https://riddddder.github.io/about/index.html","excerpt":"","text":"2021年广州毕业，目前在珠海工作，从事前端开发； 技术框架主要是vue、element-ui、uniapp、vant等； 对flutter技术感兴趣，正在尝试使用flutter的getx开发； 后端还在沉淀中，熟悉Java、MySQL、Redis，框架SpringBoot、Mybatis-Plus等； 希望有朝一日能做出自己的作品， 初始设定，大概意思就是望自己永远保持初心！"},{"title":"schedule","date":"2024-10-29T10:58:02.160Z","updated":"2024-10-29T10:58:02.160Z","comments":true,"path":"schedule/index.html","permalink":"https://riddddder.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-10-29T10:57:10.828Z","updated":"2024-10-29T10:57:10.828Z","comments":true,"path":"tags/index.html","permalink":"https://riddddder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"flex和margin","slug":"flex和margin","date":"2024-12-07T12:17:57.000Z","updated":"2024-12-07T09:42:29.759Z","comments":true,"path":"2024/12/07/flex和margin/","permalink":"https://riddddder.github.io/2024/12/07/flex%E5%92%8Cmargin/","excerpt":"","text":"常见的页面中，有一种页面就是很多个元素并排排列，然后每个元素之间有一定的间距，一行多个，占满一行换行。 这种情况下，我们可以会使用 flex 布局。 12345678.container &#123; display: flex; flex-wrap: wrap; jucstify-content: space-between; .item &#123; width: 50px; &#125;&#125; 使用 space-between ，每个元素之间会有间距，但是当最后一行不满一行的个数时，间距会有问题。 这时候，我们可以使用 margin 来处理。 12345678910.container &#123; display: flex; flex-wrap: wrap; .item &#123; --n: 3; --gap: calc(100% - 50px * var(--n)) / var(--n) / 2; width: 50px; margin: 10px var(--gap); &#125;&#125; 这样，最后一行的元素就不会有间距问题了。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Vue静态资源的动态访问","slug":"Vue静态资源的动态访问","date":"2024-12-07T05:32:49.000Z","updated":"2024-12-07T09:42:30.210Z","comments":true,"path":"2024/12/07/Vue静态资源的动态访问/","permalink":"https://riddddder.github.io/2024/12/07/Vue%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%AE%BF%E9%97%AE/","excerpt":"","text":"# 问题描述 在 Vue 项目中，静态资源在动态访问的情况下，会存在找不到资源的问题，这是因为 Vue 在打包时，会将静态资源打包到 dist 目录下。 而在动态访问静态资源时，vite 打包无法正确解析路径，导致找不到资源。 如，我们需要根据用户性别显示用户默认头像，此时需要动态访问静态资源，代码如下： 1&lt;img :src=&quot;path&quot;/&gt; 12const gender = detail.value.genderpath.value = `@/assets/$&#123;gender&#125;.png` 这时，会出现找不到资源的问题。 # 解决方案 # 使用 import 或者 require 直接引入资源 在 Vue 组件中，可以直接使用 import 或者 require 来引入静态资源，例如： 12import boy from &#x27;@/assets/1.png&#x27;import girl from &#x27;@/assets/2.png&#x27; 或者 1234const boy = require(&#x27;@/assets/1.png&#x27;)const girl = require(&#x27;@/assets/2.png&#x27;)path.value = gender === 1 ? boy : girl 这种方案可以正确解析路径，但是需要手动引入资源，当需要引入资源比较多时，还会增加代码量，比较麻烦。 # 使用 import 动态导入 在 Vue 组件中，可以使用 import 动态导入来引入静态资源，例如： 123import(`@/assets/$&#123;gender&#125;.png`).then((res) =&gt; &#123; path.value = res.default&#125;) 这种方案可以动态导入资源，但是会将 /assetsx 下的所有资源打包，并生成很多 js 资源，导致增加请求次数。 # URL 构造器 在 Vue 组件中，可以使用 URL 构造器来构造静态资源的 URL，例如： 12const url = new URL(&#x27;@/assets/logo.png&#x27;, import.meta.url).hrefpath.value = url 这种方案较为完美，可以正确解析路径，并且不会增加请求次数。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Vue发布订阅模式","slug":"Vue发布订阅模式","date":"2024-12-02T10:39:48.000Z","updated":"2024-12-07T09:42:30.930Z","comments":true,"path":"2024/12/02/Vue发布订阅模式/","permalink":"https://riddddder.github.io/2024/12/02/Vue%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"# 发布订阅模式 发布订阅模式是一种消息范式，消息的发送者（发布者）不会直接将消息发送给接收者（订阅者），而是通过一个第三方组件（通常称为事件总线或消息代理）来传递消息。 发布订阅模式的主要优点是解耦了消息的发送者和接收者，使得它们可以独立地变化和扩展。发布订阅模式广泛应用于事件驱动编程、异步编程和消息队列等领域。 # Vue 事件中心实现 eventEmitter.ts 1234567891011121314151617181920const eventName = [&#x27;EVENT_NAME&#x27;, &#x27;EVENT_NAME1&#x27;, &#x27;EVENT_NAME2&#x27;, ...] // class EventEmitter &#123; private listeners:Record&lt;string, Set&lt;Function&gt;&gt; = &#123; &#x27;EVENT_NAME&#x27;:new Set(), &#x27;EVENT_NAME1&#x27;:new Set(), &#x27;EVENT_NAME2&#x27;:new Set(), ... &#125; // 定义事件监听器 on(eventName: string, listener: Function) &#123; this.listeners[eventName].add(listener) &#125; emit(eventName: string, ...args: any[]) &#123; this.listeners[eventName].forEach((listener) =&gt; listener(...args)) &#125;&#125;export default new EventEmitter() 事件发送 12import emitter from &#x27;./eventEmitter&#x27;emitter.emit(&#x27;EVENT_NAME&#x27;) 事件监听处理 12import emitter from &#x27;./eventEmitter&#x27;emitter.on(&quot;EVENT_NAME&quot;, function() &#123;...&#125;) # 代码优化 事件优先级、事件中断","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"手写Promise.all","slug":"手写Promise-all","date":"2024-12-01T04:11:53.000Z","updated":"2024-12-07T09:42:34.110Z","comments":true,"path":"2024/12/01/手写Promise-all/","permalink":"https://riddddder.github.io/2024/12/01/%E6%89%8B%E5%86%99Promise-all/","excerpt":"","text":"123456789101112131415161718192021Promise.myAll = function (promises) &#123; let res, rej; const p = new Promise((resolve, reject) =&gt; &#123; res = resolve rej = reject &#125;) let i = 0; const result = [] for(const prom of promises) &#123; const index = i i++ Promise.resolve(porm).then((data)=&gt;&#123; result[index] = data i--; &#125;, rej) &#125;; if(i === 0) res([]) return p&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JS标签化模板","slug":"JS标签化模板","date":"2024-11-08T13:13:42.000Z","updated":"2024-11-09T11:03:37.413Z","comments":true,"path":"2024/11/08/JS标签化模板/","permalink":"https://riddddder.github.io/2024/11/08/JS%E6%A0%87%E7%AD%BE%E5%8C%96%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"# 标签化模板 # 1. 标签化模板是什么 标签模板是模板字符串使用的一种高级形式，用代码示意就是 —— 这是我们常见的模板字符串： 12const author = &#x27;zhangxinxu&#x27;;console.log(`write by $&#123;author&#125;`); 这个就是标签模板，是模板字符串使用的高级形式： 12345const author = &#x27;zhangxinxu&#x27;;function tag (arr, exp) &#123; return `$&#123;arr[0]&#125;$&#123;exp&#125;`;&#125;console.log(tag`write by $&#123;author&#125;`); 两段内容返回的结果是一样的。 仔细看 tag write by $&#123;author&#125; 这段代码，其中 tag 就是标签模板中的 “标签”， write by $&#123;author&#125; 就是标签模板中的 “模板”。 因此，“标签” 实际上并不是指的标签，而是类似于标签性质的函数，“模板” 则是这个函数的参数。 # 2. 标签化模板的语法 123456789101112let tag = function (strings, ...values) &#123; // strings是一个数组，包含了模板字符串中的每一部分 // values是一个数组，包含了模板字符串中的每一部分对应的值 // 可以在这里对模板字符串进行处理，然后返回一个字符串 return strings[0] + values[0] + strings[1] + values[1] + strings[2];&#125;;let name = &quot;Alice&quot;;let age = 20;let result = tag`My name is $&#123;name&#125;, I am $&#123;age&#125; years old.`;console.log(result); // My name is Alice, I am 20 years old. # 3. 标签化模板的应用 利用标签化模板，可以实现很多有趣的功能，比如： 这是一段 命令式编程 123456789a.style.color = getColor();a.style.backgroundColor = getBackgroundColor();a.style.fontSize = getFontSize();a.style.height = height + &#x27;px&#x27;;a.style.width = width + &#x27;px&#x27;;a.href = href;a.title = title;a.target = target;a.textContent = textContent; 我们可以通过标签化模板特性将其转换成 声明式编程 1234567891011a.styles` color: $&#123;getColor()&#125;; background-color: $&#123;getBackgroundColor()&#125;; font-size: $&#123;getFontSize()&#125;; height: $&#123;height&#125;px; width: $&#123;width&#125;px;`.props` href: $&#123;href&#125;; title: $&#123;title&#125;; target: $&#123;target&#125;;`.content($&#123;textContent&#125;); 123456789101112HTMLElement.prototype.styles = function () &#123; const styles = generateString(arguments) let curStyle = this.getAttribute(&quot;style&quot;) if(curStyle) &#123; curStyle += styles; &#125; else &#123; curStyle = styles; &#125; this.style = curStyle; return this&#125; 12345678910111213141516171819HTMLElement.prototype.props = function () &#123; const propString = generateString(arguments) propString .split(&quot;\\n&quot;) .map(it =&gt; &#123; const prats = it.trim().split(&quot;:&quot;); const key = prats[0].trim(); const value = parts.slice(1).join(&quot;:&quot;).trim(); if(value.indexOf(&quot;;&quot;)===value.length - 1) &#123; value = value.substring(0, value.length - 1) &#125; return [key, value]; &#125;) .forEach([k, v] =&gt; &#123; if(!k) &#123; return; &#125; this[k] = v; &#125;); return this;&#125; 12345HTMLElement.prototype.content = function () &#123; const content = generateString(arguments); this.textContent = content; return this&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://riddddder.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://riddddder.github.io/tags/ES6/"}]},{"title":"前端的性能优化","slug":"前端的性能优化","date":"2024-11-01T06:40:22.000Z","updated":"2024-11-06T17:49:36.748Z","comments":true,"path":"2024/11/01/前端的性能优化/","permalink":"https://riddddder.github.io/2024/11/01/%E5%89%8D%E7%AB%AF%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"# 前端性能指标 load（Onload Event），它代表页面中依赖的所有资源加载完的事件。 DCL（DOMContentLoaded），DOM 解析完毕。 FP（First Paint），表示渲染出第一个像素点。FP 一般在 HTML 解析完成或者解析一部分时候触发。 FCP（First Contentful Paint），表示渲染出第一个内容，这里的 “内容” 可以是文本、图片、canvas。 FMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义” 没有一个标准的定义，FMP 的计算方法也很复杂（建议不使用，或者结合产品经理讨论使用）。 LCP（largest contentful Paint），最大内容渲染时间。 # 体验优化 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 首屏渲染优化，请求少、加载体积小、善用缓存 动画优化，避免某些动画造成页面的卡顿 优化用户的操作感官，提升视觉反馈，比如 hover 小手，让用户一眼就知道是否可操作 长列表复用 dom，优化滚动效果及页面卡顿现象，减少页面一次性渲染的数量 骨架屏的使用 组件的预加载，懒加载 # 提升页面性能 减少 http 请求 和 冗余数据 组件，路由懒加载 配置 Nginx 优化 优化 Webpack 打包机制 使用 CDN 预渲染 SSR 图片转 base64 后台分布式部署，负载均衡 # 首页加载优化（减少白屏时间） cdn 分发：通过在多台服务器部署相同的副本，当用户访问时，服务器根据用户跟哪台服务器地理距离小或者哪台服务器此时的压力小，来决定哪台服务器去响应这个请求。 后台在业务层的缓存：数据库查询缓存是可以设置缓存的，这个对于高频率的请求很有用。值得注意的是，接口也是可以设置缓存的，比如获取一定时间内不会变的资源，设置缓存会很有用。 静态文件缓存方案：这个最常看到。现在流行的方式是文件 hash + 强缓存 的一个方案。比如 hash + cache control：max-age=1 年。 前端的资源动态加载： a. 路由动态加载，最常用的做法，以页面为单位，进行动态加载。 b. 组件动态加载（offScreen Component），对于不在当前视窗的组件，先不加载。 c. 图片懒加载 (offScreen Image)，同上。值得庆幸的是，越来越多的浏览器支持原生的懒加载，通过给 img 标签加上 loading=“lazy” 来开启懒加载模式。 利用好 async 和 defer 这两个属性：如果是独立功能的 js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，我们可以加入 defer 属性。 渲染的优先级：浏览器有一套资源的加载优先级策略，也可以通过 js 来自己控制请求的顺序和渲染的顺序。一般我们不需要这么细粒度的控制，而且控制的代码也很不好写。 前端做一些接口缓存：前端也可以做接口缓存，缓存的位置有两个，一个是内存，即保存给变量，另一个是 localStorage。比如用户的签到日历（展示用户是否签到），我们可以缓存这样的接口到 localStorage ，有效期是当天。或者有个列表页，我们总是缓存上次的列表内容到本地，下次加载时，我们先从本地读取缓存，并同时发起请求到服务器获取最新列表。 页面使用骨架屏：意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏虽然不能提高首屏加载速度，但可以减少用户在首屏等待的急躁情绪。这点很有效，在很多成熟的网站都有大量应用。 使用 SSR 渲染：服务器性能一般都很好，那么可以先在服务器先把 vdom 计算完成后，再输出给前端，这样可以节约的时间为：计算量 / (服务器计算速度 - 客户端计算速度) 。第二个是服务器可以把首屏的 ajax 请求在服务端阶段就完成，这样可以省去和客户端通过 tcp 传输的时间。 引入 http2.0：http2.0 对比 http1.1，最主要的提升是传输性能，特别是在接口小而多的时候。 选择先进的图片格式：使用 JPEG 2000，JPEG XR，and WebP 的图片格式来代替现有的 jpeg 和 png ，当页面图片较多时，这点作用非常明显。把部分大容量的图片从 BaseLine JPEG 切换成 Progressive JPEG （理解这两者的差别）也能缩小体积。 利用好 http 压缩：使用 http 压缩的效果非常明显。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"（已解决）vue-element-plus-admin打包报错","slug":"Node内存问题","date":"2024-10-24T10:51:00.000Z","updated":"2024-11-06T18:10:39.419Z","comments":true,"path":"2024/10/24/Node内存问题/","permalink":"https://riddddder.github.io/2024/10/24/Node%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 问题描述 在一次使用 vue-element-plus-admin 打包时，出现如下报错: 1FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript # 问题原因 node 内存泄漏耗尽，JavaScript 堆内存不足。因为 Node 是基于 V8 引擎，在 Node 中通过 JavaScript 使用内存时只能使用部分内存。 # 解决方法 安装依赖工具 1npm install increase-memory-limit --save 1npm install cross-env --save 修改 package.json 如下:[LIMIT 大小自己设置] 123&quot;scripts&quot;: &#123; &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=2048 increase-memory-limit&quot; &#125;, 最后执行就可以打包啦 1npm run fix-memory-limit","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"}]},{"title":"小程序的路由改造","slug":"小程序的路由改造","date":"2024-08-26T11:59:24.000Z","updated":"2024-11-21T01:08:51.004Z","comments":true,"path":"2024/08/26/小程序的路由改造/","permalink":"https://riddddder.github.io/2024/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B7%AF%E7%94%B1%E6%94%B9%E9%80%A0/","excerpt":"","text":"首先，我们需要创建一个全局的路由对象，用于存储所有的页面路径和对应的页面组件。 123456789101112// router.jsconst router = &#123; pages: [], addPage(page) &#123; this.pages.push(page); &#125;, getPage(path) &#123; return this.pages.find(page =&gt; page.path === path); &#125;&#125;;export default router; 然后，我们需要在每个页面组件中注册自己的路径和对应的页面组件。 1234567// index.jsimport router from &#x27;./router&#x27;;router.addPage(&#123; path: &#x27;/pages/index/index&#x27;, component: require(&#x27;./index&#x27;).default&#125;); 接下来，我们需要在 app.js 中初始化路由对象，并注册全局的路由方法。 12345678910111213141516171819202122232425262728293031323334// app.jsimport router from &#x27;./router&#x27;;App(&#123; onLaunch() &#123; // 初始化路由对象 router.pages = this.pages; &#125;, navigateTo(options) &#123; const page = router.getPage(options.url); if (page) &#123; // 如果页面存在，则跳转到对应的页面 page.component.navigateTo(options); &#125; else &#123; // 如果页面不存在，则跳转到404页面 wx.navigateTo(&#123; url: &#x27;/pages/404/404&#x27; &#125;); &#125; &#125;, redirectTo(options) &#123; const page = router.getPage(options.url); if (page) &#123; // 如果页面存在，则跳转到对应的页面 page.component.redirectTo(options); &#125; else &#123; // 如果页面不存在，则跳转到404页面 wx.redirectTo(&#123; url: &#x27;/pages/404/404&#x27; &#125;); &#125; &#125;, // 其他路由方法...&#125;); 最后，我们需要在每个页面组件中实现自己的路由方法。 123456789101112// index.jsimport router from &#x27;./router&#x27;;Page(&#123; navigateTo(options) &#123; wx.navigateTo(options); &#125;, redirectTo(options) &#123; wx.redirectTo(options); &#125;, // 其他页面方法...&#125;); 通过以上改造，我们就可以在全局范围内使用统一的路由方法，并且可以根据需要动态加载页面组件。这样不仅提高了代码的可维护性，还使得路由管理更加灵活和可扩展。","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://riddddder.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"hexo主题-自制主题指北","slug":"hexo/hexo主题-自制主题指北","date":"2024-01-01T01:01:48.000Z","updated":"2024-11-21T01:09:58.649Z","comments":true,"path":"2024/01/01/hexo/hexo主题-自制主题指北/","permalink":"https://riddddder.github.io/2024/01/01/hexo/hexo%E4%B8%BB%E9%A2%98-%E8%87%AA%E5%88%B6%E4%B8%BB%E9%A2%98%E6%8C%87%E5%8C%97/","excerpt":"","text":"# 参考资料 Hexo 主题开发","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]},{"title":"后台管理系统：权限控制的设计","slug":"后台管理-权限控制","date":"2023-10-31T15:26:23.000Z","updated":"2024-11-06T17:50:08.458Z","comments":true,"path":"2023/10/31/后台管理-权限控制/","permalink":"https://riddddder.github.io/2023/10/31/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"# 背景 # 意义 # 权限的分类 # 后端权限 从根不上讲前端仅仅只是视图层的展示，权限的核心是在于服务器中的数据变； 所以后端才是权限的关键，后端权限可以控制某个用户是否能够查询数据， 是否能够修改数据等操作 # 前端权限 前端权限的控制本质上来说， 就是控制端的视图层的展示和前端所发送的请求。 但是只有前端权限控制没有后端权限控制是万万不可的。 # 前端权限的意义 如果仅从能够修改服务器中数据库中的数据层面上讲， 确实只在后端做控制就足够了， 那为什么越来越多的项目也进行了前端权限的控制， 主要有这几方面的好处 降低非法操作的可能性 不怕赃偷就怕贼惦记， 在页面中展示出一个就算点击了也最终会失败的按钮，势必会增加有心者非法操作的可能性 尽可能排除不必要清求， 减轻服务器压力 没必要的请求，操作失败的清求，不具备权限的清求，应该压根就不需要发送，请求少了，自然也会减轻服务器的压力 提高用户体验 根据用户具备的权限为该用户展现自己权限范围内的内容，避免在界面上给用户带来困扰，让用户专注于分内之事 # 前端权限控制的设计思路 # 菜单权限 在登录请求中， 会得到权限数据。前端根据权限数据， 展示对应的菜单，点击菜单才能查看相关的界面 # 按钮 / 超链接权限 在某个菜单的界面中， 还得根据权限数据， 展示出可进行操作的按钮，比如删除， 修改， 增加 # 界面控制权限 如果用户没有登录， 手动在地址栏敲入管理界面的地址， 则需要跳转到登录界面 如果用户已经登录， 如果手动敲入非权限内的地址， 则需要跳转 404 界面 # 请求和响应的控制 如果用户通过非常规操作， 比如通过浏览器调试工具将某些禁用的按钮变成启用状态， 此时发的请求， 也应该被前端所拦截 # 前端权限控制的实现 # 权限菜单栏控制 用户登录之后服务端返回一个数据，这个数据有菜单列表和 token，我们把这个数据放入到 vuex 中，然后主页根据 vuex 中的数据进行菜单列表的渲染 问题： 刷新界面 vuex 数据消失，菜单栏消失 解决： 将数据存储在 sessionStorage 中，并让其和 vuex 中的数据保持同步 # 界面的控制 路由导航守卫 动态路由","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"怎么处理浏览器兼容性","slug":"浏览器兼容性","date":"2023-01-29T02:54:42.000Z","updated":"2024-11-05T16:40:42.266Z","comments":true,"path":"2023/01/29/浏览器兼容性/","permalink":"https://riddddder.github.io/2023/01/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/","excerpt":"","text":"# 浏览器兼容性 1面试官：说说你在工作中是怎么处理浏览器兼容性 这个问题，是面试官想知道你的学习广度，你的知识体系是否全面。 其实针对前端三部分（HTML、CSS、JavaScript），考虑浏览器兼容性只有 CSS 和 JavaScript；因为针对 HTML，在开发中就常用的几个标签，浏览器从头到脚都认识，还需要兼容吗？ 针对 CSS 的兼容性，你只需要有添加浏览器前缀，变量转换等意识即可 针对 JavaScript 的兼容性，你只需要有新旧语法兼容和新旧函数兼容意识即可。 只需要有这两个意识就行，实现也已经不需要从头到尾的写，而是借助工具即可 # CSS 兼容性 # 浏览器前缀 浏览器前缀是浏览器厂商为了实验性 CSS 属性而添加的标识符，它们通常用于 CSS 规则的前面。以下是一些常见的浏览器前缀： webkit-：用于 Chrome、Safari（WebKit 内核） moz-：用于 Firefox（Gecko 内核） o-：用于 Opera（Presto 内核，已逐渐淘汰） ms-：用于 Internet Explorer（Trident 内核） 例如，如果你想要使用 CSS 的 transform 属性，可能需要添加所有浏览器的前缀： 1234567.element &#123; -webkit-transform: rotate(45deg); /* Chrome, Safari */ -moz-transform: rotate(45deg); /* Firefox */ -ms-transform: rotate(45deg); /* IE */ -o-transform: rotate(45deg); /* Opera */ transform: rotate(45deg); /* 标准语法 */&#125; 为了简化这个过程，可以使用一些工具自动添加浏览器前缀： Autoprefixer：一个后处理工具，可以根据 Can I Use 的数据自动添加所需的浏览器前缀。 PostCSS：一个使用 JavaScript 的插件系统，可以处理 CSS 的转换，包括添加前缀。 # 变量转换 CSS 变量的兼容性问题较少，因为它们已经成为 CSS 的一个标准部分。 但是，为了确保在不支持 CSS 变量的旧浏览器中也能正常显示，可以使用以下方法： 回退值：在 var () 函数中提供回退值。 PostCSS：使用 PostCSS 插件将 CSS 变量转换为静态值。 # JavaScript 的兼容性 再来说说 JavaScript 的兼容性吧，针对新旧语法的兼容可以作转换，而针对新旧函数的兼容就需要加补丁。 # babel 其实在开发过程中，最常见的就是跟 JavaScript 打交道，也会真实感受到 JavaScript 存在新的语法，那么这些新的语法就需要转化，才能被浏览器认识。那么这时候就可以借助一个工具 babel。用于专门来降低 JavaScript 语法的。 babel 就是一个编译器，把一段源代码转化成另外一段新代码，新代码就能被浏览器识别。对了，既然 babel 是工具（postcss 也是一样），能单独使用，也能够配合使用。而我们在项目开发过程中，都会使用构建工具（比如说 webpack），但是又想使用 babel 工具，那么这时候就需要一个桥梁，而 webpack 中的桥梁就是 babel-loader，具体怎么操作你回去研究一下。 # polyfill 手动打补丁 根据覆盖率自动打补丁 根据浏览器特性，动态打补丁 JS 代码能够被转化减低，适配了市场占比的浏览器，是不是就已经完成了呢？当然没有。 在 ES6 中出现了 Promise，fetch，以及数组和字符串新的方法，babel 会进行转化吗？会转化成什么呢？肯定不会被转化撒，因为它们都是函数调用，对于 babel 来说就是一个普通的函数调用，只是找不到函数的实现体而已，只是会报错而已。 那么这里也就需要兼容一下，因为新版本的浏览器是认识的，老版本的浏览器是不认识的，那么这里就需要为了兼容了老版浏览器，新部署一个 JS 文件（类似补丁），里面存放了各个函数（promise, fetch）体的实现代码。然后浏览器就能够正常的识别了。 # 参考文章 掘金 - 面试官：说说你在工作中是怎么处理浏览器兼容性","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"hexo主题-shako主题食用","slug":"hexo/hexo主题-shako主题食用","date":"2022-12-31T16:00:00.000Z","updated":"2024-11-21T01:09:49.035Z","comments":true,"path":"2023/01/01/hexo/hexo主题-shako主题食用/","permalink":"https://riddddder.github.io/2023/01/01/hexo/hexo%E4%B8%BB%E9%A2%98-shako%E4%B8%BB%E9%A2%98%E9%A3%9F%E7%94%A8/","excerpt":"","text":"shako 主题比较唯美，很可爱，适合萌妹。 缺点资源太多，部署在 github 上加载有点慢。 # 安装主题 这一步直接在博客项目文件中执行，安装好的主题会在 ./themes/shako 中 1git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 在_config.yml 中设置 1theme: shoka # shoka 的配置 主题主页：https://shoka.lostyu.me/ 文档说明：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/ 基本配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/ 页面配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/ 依赖插件: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]},{"title":"常见的加密","slug":"常见的加密","date":"2022-08-22T11:16:12.000Z","updated":"2024-11-15T10:06:11.931Z","comments":true,"path":"2022/08/22/常见的加密/","permalink":"https://riddddder.github.io/2022/08/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86/","excerpt":"","text":"# 加密 # AES 对称加密，加密和解密使用同一个密钥 # AES 应用场景 数据传输 # AES 代码示例 123456789101112131415161718import CryptoJS from &#x27;crypto-js&#x27;const key = CryptoJS.enc.Utf8.parse(&#x27;1234567890123456&#x27;) // 密钥const iv = CryptoJS.enc.Utf8.parse(&#x27;1234567890123456&#x27;) // 偏移量// 加密const encryptedData = CryptoJS.AES.encrypt(&#x27;hello world&#x27;, key, &#123; iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;).toString()// 解密const decryptedData = CryptoJS.AES.decrypt(encryptedData, key, &#123; iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;).toString(CryptoJS.enc.Utf8) # RSA 非对称加密，加密和解密使用不同的密钥 # RSA 应用场景 数据传输 # RSA 代码示例 123456789101112131415161718192021const crypto = require(&#x27;crypto&#x27;)// 生成密钥对const &#123; publicKey, privateKey &#125; = crypto.generateKeyPairSync(&#x27;rsa&#x27;, &#123; modulusLength: 2048, publicKeyEncoding: &#123; type: &#x27;pkcs1&#x27;, format: &#x27;pem&#x27; &#125;, privateKeyEncoding: &#123; type: &#x27;pkcs1&#x27;, format: &#x27;pem&#x27; &#125;&#125;)// 加密const encryptedData = crypto.publicEncrypt(publicKey, Buffer.from(&#x27;hello world&#x27;))// 解密const decryptedData = crypto.privateDecrypt(privateKey, encryptedData) # MD5、SHA-1\\SHA-256 哈希算法，不可逆 # MD5 应用场景 1. 文件完整性检查 2. 密码哈希存储 3. 数字签名 # MD5 代码示例 1234const crypto = require(&#x27;crypto&#x27;)const md5 = crypto.createHash(&#x27;md5&#x27;)md5.update(&#x27;hello world&#x27;)const hash = md5.digest(&#x27;hex&#x27;) 12const md5 = require(&#x27;md5&#x27;)const hash = md5(&#x27;hello world&#x27;) SHA-256 1234const crypto = require(&#x27;crypto&#x27;)const sha256 = crypto.createHash(&#x27;sha256&#x27;)sha256.update(&#x27;hello world&#x27;)const hash = sha256.digest(&#x27;hex&#x27;) # SHA 哈希算法，不可逆 # SHA 应用场景 密码明文转密文存储 # SHA 代码示例 # Base64 编码算法，可逆，常用于图片、音频等二进制数据的编码 # Base64 应用场景 # Base64 代码示例 图片转 base64 12const fs = require(&#x27;fs&#x27;)const base64 = fs.readFileSync(&#x27;image.png&#x27;, &#x27;base64&#x27;) base64 转图片 123const fs = require(&#x27;fs&#x27;)const base64 = &#x27;data:image/png;base64,iVBORw0KGg...&#x27;fs.writeFileSync(&#x27;image.png&#x27;, base64, &#x27;base64&#x27;)","categories":[],"tags":[]},{"title":"前端笔记：节流和防抖","slug":"前端笔记/前端笔记-节流和防抖","date":"2021-11-04T08:16:29.000Z","updated":"2024-11-21T01:11:04.446Z","comments":true,"path":"2021/11/04/前端笔记/前端笔记-节流和防抖/","permalink":"https://riddddder.github.io/2021/11/04/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","excerpt":"","text":"# 区别 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 # 应用场景 节流：滚动条监听、搜索框输入 防抖：输入框搜索、窗口大小 resize # 实现 节流: 一定时间内的无论点击多少次，都只会执行第一次，其余的直接 return 12345678910function throttled1(fn, delay = 500) &#123; let oldtime = Date.now() return function (...args) &#123; let newtime = Date.now() if (newtime - oldtime &gt;= delay) &#123; fn.apply(null, args) oldtime = Date.now() &#125; &#125;&#125; 1234567891011function throttled2(fn, delay = 500) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) timer = null &#125;, delay); &#125; &#125;&#125; 1234567891011121314151617function throttled(fn, delay) &#123; let timer = null let starttime = Date.now() return function () &#123; let curTime = Date.now() // 当前时间 let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间 let context = this let args = arguments clearTimeout(timer) if (remaining &lt;= 0) &#123; fn.apply(context, args) starttime = Date.now() &#125; else &#123; timer = setTimeout(fn, remaining); &#125; &#125;&#125; 防抖: 1234567891011function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; // 保存this指向 let args = arguments; // 拿到event对象 clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 12345678910111213141516171819202122function debounce(func, wait, immediate) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); // timeout 不为null if (immediate) &#123; let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发 timeout = setTimeout(function () &#123; timeout = null; &#125;, wait) if (callNow) &#123; func.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"localStorage和sessionStorage","slug":"localStorage和sessionStorage","date":"2021-08-10T04:51:59.000Z","updated":"2024-11-06T17:55:07.371Z","comments":true,"path":"2021/08/10/localStorage和sessionStorage/","permalink":"https://riddddder.github.io/2021/08/10/localStorage%E5%92%8CsessionStorage/","excerpt":"","text":"# 基本概念 localStorage 和 sessionStorage 都是 Web Storage API 的一部分，用于在客户端存储数据。它们都是键值对存储，可以存储字符串数据，也可以存储对象数据。 # 区别 localStorage 和 sessionStorage 的主要区别在于数据的生命周期。localStorage 的数据会一直存在，直到手动删除，而 sessionStorage 的数据在页面会话结束时会被清除。 # 作用域不同 sessionStorage 的作用域限定在当前会话（当前浏览器标签页或窗口）。 localStorage 的作用域是永久的，数据在不同会话（遵循同源策略）之间共享。 # 生命周期不同 sessionStorage 的数据在会话结束时被清除，即当用户关闭浏览器标签页或窗口时，sessionStorage 中的数据会被删除。 localStorage 的数据是持久化的，除非被显式清除，否则会一直保存在客户端。 # 存储大小不同 sessionStorage 的存储容量通常比 localStorage 小。一般来说，sessionStorage 的容量限制在 5MB 左右。 localStorage 的容量限制通常在 5MB 到 10MB 之间，不同浏览器可能会有所不同。 # 数据共享不同 sessionStorage 的数据在同一个浏览器标签页或窗口中共享，但不会跨标签页或窗口共享。 localStorage 的数据在同一个域名下的所有标签页和窗口中共享。 # 使用场景 sessionStorage 适用于存储需要在同一会话中共享的数据，例如用户的登录状态、表单数据等。当用户关闭浏览器标签页或窗口时，这些数据会被自动清除。 localStorage 适用于存储需要在多个会话中共享的数据，例如用户的偏好设置、购物车数据等。这些数据会一直保存在客户端，直到被显式清除。 # 使用方法 # localStorage 1234567891011// 存储数据localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);// 获取数据var value = localStorage.getItem(&#x27;key&#x27;);// 删除数据localStorage.removeItem(&#x27;key&#x27;);// 清空所有数据localStorage.clear(); # sessionStorage 1234567891011// 存储数据sessionStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);// 获取数据var value = sessionStorage.getItem(&#x27;key&#x27;);// 删除数据sessionStorage.removeItem(&#x27;key&#x27;);// 清空所有数据sessionStorage.clear(); # 注意事项 localStorage 和 sessionStorage 的数据存储遵循同源策略，即只有在相同域名、相同协议和相同端口下的页面才能访问这些数据。 localStorage 和 sessionStorage 的数据存储是同步的，即调用 setItem 、 getItem 、 removeItem 和 clear 方法会立即生效，不会阻塞页面的渲染。因此，在调用这些方法时，需要注意不要在关键路径上使用它们，以免影响页面的性能。 localStorage 和 sessionStorage 的数据存储是字符串类型的，如果需要存储非字符串类型的数据，可以使用 JSON.stringify 和 JSON.parse 方法进行序列化和反序列化。 localStorage 和 sessionStorage 的数据存储是持久化的，即数据不会在页面关闭后自动清除。如果需要清除数据，可以使用 removeItem 或 clear 方法。 localStorage 和 sessionStorage 的数据存储大小有限制，一般为 5MB 左右，不同浏览器可能会有所不同。如果需要存储大量数据，可以考虑使用其他存储方式，如 IndexedDB。 localStorage 和 sessionStorage 的数据存储是安全的，即数据不会被第三方脚本访问。但是，如果页面中存在 XSS 攻击，攻击者可以通过注入恶意脚本访问这些数据。因此，在使用 localStorage 和 sessionStorage 时，需要注意不要存储敏感数据，以免造成安全风险。 localStorage 和 sessionStorage 的数据存储是可被浏览器清除的，如用户手动清除浏览器缓存、浏览器崩溃等。因此，在使用 localStorage 和 sessionStorage 时，需要注意数据的持久化和安全性。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端笔记：ES6","slug":"前端笔记/前端笔记-ES6","date":"2021-07-19T04:32:04.000Z","updated":"2024-11-21T01:10:34.747Z","comments":true,"path":"2021/07/19/前端笔记/前端笔记-ES6/","permalink":"https://riddddder.github.io/2021/07/19/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-ES6/","excerpt":"","text":"# ES 基础知识 # let 和 const # symbol Symbol 是 ES6 中引入的一种新的基本数据类型，用于表示一个独一无二的值，不能与其他数据类型进行运算。它是 JavaScript 中的第七种数据类型 1234const a = Symbol();console.log(a); //Symbol()const a = new Symbol();//报错，Symbol is not a constructor，因为Symbol是基本数据类型，而不是对象，不能 new 。 # class # 字符串新特性 # 模板字符串 使用反引号 `` 和 ${} 来引用变量 # 字符串新方法 includes () 判断字符串是否包含参数字符串，返回 boolean 值。 startsWith () /endsWith ()，判断字符串是否以参数字符串开头或结尾。返回 boolean 值。这两个方法可以有第二个参数，一个数字，表示开始查找的位置 repeat () 方法按指定次数返回一个新的字符串。 1console.log(&quot;hello&quot;.repeat(2)//&quot;hellohello&quot; padStart ()/padEnd ()，用参数字符串按给定长度从前面或后面补全字符串，返回新字符串。 # 数组新方法 Array.from () 是内置对象 Array 的方法，实例数组不能调用 includes () 参数：数值 -------- 返回值：true/false map ()、filter () 参数：函数 -------- 返回值：数组 forEach () 参数：函数 -------- 返回值：undefined find () 参数：函数 -------- 返回值：数值 some ()、every () 参数：函数 -------- 返回值：true/false # object 新方法 Object.is() Object.assign() Object.keys() Object.values() Object.entries() # 对象扩展符 # 拷贝 12345let obj = &#123;name: &quot;xiaoming&quot;, age: 18&#125;;let obj1 = &#123;...obj&#125;;console.log(obj1 === obj);//falseobj1.name = &quot;xiaohong&quot;;console.log(obj.name);//xiaoming # 合并 1234let obj = &#123;name: &quot;xiaoming&quot;, age: 18&#125;;let obj1 = &#123;sex: &quot;male&quot;&#125;;let obj2 = &#123;...obj, ...obj1&#125;;console.log(obj2);//&#123;name: &quot;xiaoming&quot;, age: 18, sex: &quot;male&quot;&#125; # 箭头函数 箭头函数实现了一种更加简洁的书写方式。箭头函数内部没有 arguments，也没有 prototype 属性，所以不能用 new 关键字调用箭头函数 箭头函数和普通函数最大的区别在于其内部 this 永远指向其父级对象的 this。(重点) # 解构赋值 - 解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 字符串、以及 ES6 新增的 Map 和 Set 都可以使用解构表达式 1234567let [a, b, c, d, e] = &quot;Hello&quot;;// 字符串解构let &#123; name, age, sex &#125; = &#123; name: &quot;xiaoming&quot;, age: 18, sex: &quot;male&quot; &#125;;// 对象解构let [a,b,c] = [1,2,3]; // 数组解构let [a,..b] = [1,2,3]; //...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给bconsole.log(a,b);//1,[2,3]let [foo, [[bar], baz]] = [1, [[2], 3]]; // 嵌套数组解构 # Promise # async/await 语法糖 # 模块化 # 新增对象 # Set 可以理解为后端的 Set 集合对象 (ArrayList) Set 对象和 Map 对象类似，但它存储不是键值对。类似数组，但它的每个元素都是唯一的。 WeakSet 1234let set = new Set([1,2,3]);set.add(4);set.delete(1);set.has(2); // true # Map Map 对象用于保存键值对，任何值 JavaScript 支持的值都可以作为一个键（key）或者一个值（value）。与对象不同的是： object 的键只能是字符串或 ES6 的 symbol 值，而 Map 可以是任何值。 Map 对象有一个 size 属性，存储了键值对的个数，而 object 对象没有类似属性。 WeakMap 12345678910let map = new Map();map.set(&quot;name&quot;, &quot;xiaoming&quot;);map.set(&quot;age&quot;, 18);map.set(&quot;sex&quot;, &quot;male&quot;);map.get(&quot;name&quot;); // &quot;xiaoming&quot;map.has(&quot;name&quot;); // truemap.delete(&quot;name&quot;); // truemap.has(&quot;name&quot;); // falseconsole.log(map.size); // 3map.clear(); // 清空map # for…of for…of 循环是 ES6 引入的一种新的循环机制，用于遍历可迭代对象（如数组、字符串等）的元素。在字符串上使用 for…of 可以方便地遍历字符串中的每个字符。 1234et str = &quot;Hello&quot;;for (let char of str) &#123; console.log(char);&#125; # for…in (阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版)[https://www.bookstack.cn/read/es6-3rd/sidebar.md]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端笔记：javascript基础","slug":"前端笔记/前端笔记-Javascript面试","date":"2021-07-10T09:51:56.000Z","updated":"2024-11-21T01:10:43.285Z","comments":true,"path":"2021/07/10/前端笔记/前端笔记-Javascript面试/","permalink":"https://riddddder.github.io/2021/07/10/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-Javascript%E9%9D%A2%E8%AF%95/","excerpt":"","text":"# javascript 笔记 # js 的数据类型 基本数据类型：Number、String、Boolean、Null、Undefined、Object、（Symbol、bigInt） 引用数据类型：Array、Function、Object Null 只有一个值，是 null。不存在的对象。 Undefined 只有一个值，是 undefined。没有初始化。undefined 是从 null 中派生出来的。 简单理解就是：undefined 是没有定义的，null 是定义了但是为空。 Symbol 类型的对象永远不相等，即便创建的时候传入相同的值。因此，可以用解决属性名冲突的问题（适用于多少编码），做为标记。 # var，let，const 的区别 var 全局变量，能重复声明 let 局部变量，代码块内有效，不能重复声明 const 常量，一旦声明，常量的值就不能改变，就必须立即初始化，不能留到以后赋值 # es6 有哪些新特性 let const 模板字符串 扩展运算符 解构赋值 箭头函数 Promise、async/await 数组新方法：map、filter、reduce、some、every # 检测数组类型的方法 instanceof of， 例：arr instanceof Array constructor , 例：arr.constructor === Array Array.isArray(arr) call 方法，例：Object.prototype.toString.call (arr) === ‘[object Array]’ # 数组的方法 改变原数组：push、pop、shift、unshift、sort、splice、reverse 不改变原属组：concat、join、map、forEach、filter、slice # 字符串方法 1 charAt (x) 返回字符串中 x 字符的位置，下标从 0 开始 2 charCodeAt (x) 返回字符串中 x 位置处字符的 unicode 值 3 concat () 用于连接两个或多个字符串 4 fromCharcode () 将一组 Unicode 码转换为字符 5 indexOf (substr, [start]) 返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。 6 lastIndexOf (substr, [start]) 返回指定文本在字符串中最后一次出现的索引，如果未找到，则返回 - 1。 7 match (regexp) 根据正则表达式在字符串中搜索匹配项。如果没有找到匹配项，则返回 null。 8 replace (regexp/substr, replacetext) 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 9 search (regexp) 检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，如果找到，返回与 regexp 相匹配的子串的起始位置，否则返回 -1。 10 slice (start, [end]) 裁取字符串的某个部分，返回一个新的字符串。包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符 11 split (delimiter, [limit]) split () 方法用于把一个字符串分割成字符串数组，返回一个字符串数组，返回的数组中的字串不包括 delimiter 自身。 可选的 “limit” 是一个整数，允许各位指定要返回的最大数组的元素个数。 12 substr (start, [length]) 在字符串中抽取从 start 下标开始的指定数目的字符。返回一个新的字符串，包含从 start（包括 start 所指的字符） 处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到该字符串的结尾的字符。 13 substring (start,stop) 用于提取字符串中介于两个指定下标之间的字符 14 toLowerCase () 把字符串转换为小写。 15 toUpperCase () 把字符串转换为大写。 16 includes () 检查字符串是否包含指定的字符串或字符。 17 endsWith () 检查字符串是否以指定的字符串或字符结束。 18 repeat () 将字符串复制指定次数。 19 valueOf () 返回一个 String 对象的原始值（primitive value），该值等同于 String.prototype.toString ()。 20 trim () 从一个字符串的两端删除空白字符。 # 匿名函数和箭头函数 function 后并没有给函数命名，而是把整个函数直接赋值给变量 abs，调用时通过 abs (9) 来调用此函数。 箭头函数的定义用的就是一个箭头。箭头函数表面上相当于匿名函数，并且简化了函数定义。 当箭头函数只包含一个表达式时，它连 {…} 和 return 都省掉了。 # 水平垂直居中的方法 # 定位法 定位，position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto; 定位，position: absolute; top: 50%; left: 50%; transform: translate (-50%, -50%); 定位，(已知子元素宽高) width:100px;height:100px;position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; # flex 布局 diplay: flex; justify-content: center; align-items: center; # grid 网格布局 diplay: grid; align-items:center;justify-content: center; # table 表格布局 设置父元素为 display:table-cell，子元素设置 display: inline-block。利用 vertical 和 text-align 可以让所有的行内块级元素水平垂直居中 # 继承的方式 原型继承：不能传参 组合继承： 调用了两次父类的构造函数，不共享父类引用属性 寄生组合继承： ES6 的 extend：子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话必须是 super # 深拷贝和浅拷贝 # 深拷贝 JSON.parse(JSON.stringify(obj)) 递归拷贝 1234567891011121314151617function deepCopy(obj) &#123; // 判断是否为null或者不是对象 if (obj &amp;&amp; typeof obj !== &#x27;object&#x27;) &#123; return obj; &#125; // 判断是对象还是数组 let copy = Array.isArray(obj) ? [] : &#123;&#125;; // 遍历 for (le t key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 递归 copy[key] = deepCopy(obj[key]); &#125; &#125; return copy;&#125; # 浅拷贝 let obj1 = Object.assign({}, obj) 扩展运算符 1let obj1 = &#123; ...obj &#125; Array.prototype.slice() Array.prototype.concat()","categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"hexo主题-NexT主题食用","slug":"hexo/hexo主题-NexT主题食用","date":"2021-06-30T11:00:03.000Z","updated":"2024-11-21T01:09:41.619Z","comments":true,"path":"2021/06/30/hexo/hexo主题-NexT主题食用/","permalink":"https://riddddder.github.io/2021/06/30/hexo/hexo%E4%B8%BB%E9%A2%98-NexT%E4%B8%BB%E9%A2%98%E9%A3%9F%E7%94%A8/","excerpt":"","text":"NexT 主题是一个非常简洁的主题，非常适合新手使用。下面我将介绍如何安装和使用 NexT 主题： # 安装主题 这一步直接在博客项目文件中执行，安装好的主题会在 ./themes/next 中 1git clone https://github.com/next-theme/hexo-theme-next ./themes/next 在_config.yml 中设置 1theme: next # NexT 的配置 打开 ./themes/next/_config.yml 搜索 menu 可配置菜单，将需要的菜单注释去掉，并添加菜单项，如： 123456789menu: home: / || fa fa-home tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive # schedule: /schedule/ || fa fa-calendar # sitemap: /sitemap.xml || fa fa-sitemap about: /about/ || fa fa-user # commonweal: /404/ || fa fa-heartbeat 去掉之后，在浏览器依旧是看不到内容的，需要创建对应页面。 123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot;hexo new page &quot;about&quot; 并且需要在创建好的页面中添加 type 字段，如： /tags/index.md 12title: tagstype: &quot;tags&quot; /categories/index.md 12title: categoriestype: &quot;categories&quot; 在 /about/index.md 可编辑关于页面内容。 123456---title: abouttype: &quot;about&quot;---&lt;p align=&quot;center&quot;&gt;关于我&lt;/p&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]},{"title":"Hello Hexo","slug":"history/hello-hexo","date":"2021-06-29T14:21:44.000Z","updated":"2024-10-31T16:03:15.034Z","comments":true,"path":"2021/06/29/history/hello-hexo/","permalink":"https://riddddder.github.io/2021/06/29/history/hello-hexo/","excerpt":"","text":"# hexo 介绍 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 # 安装前准备 Node.js 12.0 以上版本，下载 git 下载 如果工作需要装了 node 可以安装 nvm 管理多版本 node。 # 安装 安装好 node 后，执行下列命令就可以完成 blog 文件夹初始化（blog 为任意空文件夹名称） 1234npm install -g hexo-clihexo init blogcd blognpm install 然后再执行 1hexo s 就可以看到控制台输出 localhost:4000 就可以在本地浏览器访问啦 # 主题 shoka 在 blog 文件夹 1git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 在_config.yml 中设置 1theme: shoka # 主题 next 在 blog 文件夹 1git clone https://github.com/next-theme/hexo-theme-next ./themes/next 在_config.yml 中设置 1theme: next # 插件 hexo-admin 1$npm install hexo-admin -s 安装好后 locahost:4000/admin 访问 # 文章 # 新建草稿 草稿是没发布是不会显示的 1hexo new draft 草稿文件名 # 新建文章 -p, --path: 自定义新文章的路径 -r, --replace: 如果存在同名文章，将其替换 -s, --slug: 文章的 Slug，作为新文章的文件名和发布后的 URL 1hexo new 文章标题 # 发布 # 发布草稿 1hexo publish 文章文件名 # 清除文章缓存 发布前需要清除存在的缓存 db.json 和 public 文件夹下的静态文件。 1hexo clean # 生成静态文件 1hexo g # 部署 部署到 git 上，需要先配置 git 1hexo d # 参考资料 [hexo 官网] https://hexo.io/zh-cn/docs/ [front-matter] https://hexo.io/zh-cn/docs/front-matter.html [shoka-github] https://github.com/amehime/hexo-theme-shoka?tab=readme-ov-file [shoka 文档] https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/ [next 官网] https://theme-next.iissnan.com/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://riddddder.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://riddddder.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://riddddder.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://riddddder.github.io/tags/ES6/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"},{"name":"小程序","slug":"小程序","permalink":"https://riddddder.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"},{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"学习","slug":"学习","permalink":"https://riddddder.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]}