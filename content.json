{"meta":{"title":"初始设定","subtitle":"","description":"","author":"Ridder","url":"https://Riddddder.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-10-28T10:00:45.000Z","updated":"2024-10-28T10:00:45.024Z","comments":true,"path":"categories/index.html","permalink":"https://riddddder.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-10-28T10:01:47.478Z","comments":true,"path":"404.html","permalink":"https://riddddder.github.io/404.html","excerpt":"","text":""},{"title":"friends","date":"2024-10-28T10:01:12.000Z","updated":"2024-10-28T10:01:12.260Z","comments":true,"path":"friends/index.html","permalink":"https://riddddder.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2024-10-28T10:01:01.000Z","updated":"2024-10-28T10:01:01.079Z","comments":true,"path":"contact/index.html","permalink":"https://riddddder.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-10-28T10:00:39.000Z","updated":"2024-10-28T10:00:39.444Z","comments":true,"path":"tags/index.html","permalink":"https://riddddder.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2024-10-28T10:00:25.000Z","updated":"2024-10-28T10:00:25.871Z","comments":true,"path":"about/index.html","permalink":"https://riddddder.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"怎么处理浏览器兼容性","slug":"浏览器兼容性","date":"2024-10-29T02:54:42.000Z","updated":"2024-10-29T10:29:40.526Z","comments":true,"path":"2024/10/29/浏览器兼容性/","permalink":"https://riddddder.github.io/2024/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/","excerpt":"","text":"1面试官：说说你在工作中是怎么处理浏览器兼容性 这个问题，是面试官想知道你的学习广度，你的知识体系是否全面。其实在平时的开发过程中，谁会注意这些呀 其实针对前端三部分（HTML、CSS、JavaScript），考虑浏览器兼容性只有 CSS 和 JavaScript；因为针对 HTML，在开发中就常用的几个标签，浏览器从头到脚都认识，还需要兼容吗？ 针对 CSS 的兼容性，你只需要有添加浏览器前缀，变量转换等意识即可 针对 JavaScript 的兼容性，你只需要有语法降级等意识即可。 只需要有这两个意识就行，实现就不需要你从头到尾的写，而是借助工具即可 # CSS 兼容性 # 浏览器前缀 浏览器前缀是浏览器厂商为了实验性 CSS 属性而添加的标识符，它们通常用于 CSS 规则的前面。以下是一些常见的浏览器前缀： webkit-：用于 Chrome、Safari（WebKit 内核） moz-：用于 Firefox（Gecko 内核） o-：用于 Opera（Presto 内核，已逐渐淘汰） ms-：用于 Internet Explorer（Trident 内核） 例如，如果你想要使用 CSS 的 transform 属性，可能需要添加所有浏览器的前缀： 1234567.element &#123; -webkit-transform: rotate(45deg); /* Chrome, Safari */ -moz-transform: rotate(45deg); /* Firefox */ -ms-transform: rotate(45deg); /* IE */ -o-transform: rotate(45deg); /* Opera */ transform: rotate(45deg); /* 标准语法 */&#125; 为了简化这个过程，可以使用一些工具自动添加浏览器前缀： Autoprefixer：一个后处理工具，可以根据 Can I Use 的数据自动添加所需的浏览器前缀。 PostCSS：一个使用 JavaScript 的插件系统，可以处理 CSS 的转换，包括添加前缀。 # 变量转换 CSS 变量的兼容性问题较少，因为它们已经成为 CSS 的一个标准部分。但是，为了确保在不支持 CSS 变量的旧浏览器中也能正常显示，可以使用以下方法： 回退值：在 var () 函数中提供回退值。 PostCSS：使用 PostCSS 插件将 CSS 变量转换为静态值。 # JavaScript 的兼容性 再来说说 JavaScript 的兼容性吧，大概就两个部分新就语法兼容和新旧函数兼容， 其实在开发过程中，最常见的就是跟 JavaScript 打交道，也会真实感受到 JavaScript 存在新的语法，那么这些新的语法就需要转化，才能被浏览器认识。那么这时候就可以借助一个工具 babel。用于专门来降低 JavaScript 语法的。 # babel babel 就是一个编译器，把一段源代码转化成另外一段新代码，新代码就能被浏览器识别。对了，既然 babel 是工具（postcss 也是一样），能单独使用，也能够配合使用。而我们在项目开发过程中，都会使用构建工具（比如说 webpack），但是又想使用 babel 工具，那么这时候就需要一个桥梁，而 webpack 中的桥梁就是 babel-loader，具体怎么操作你回去研究一下。 # polyfill 手动打补丁 根据覆盖率自动打补丁 根据浏览器特性，动态打补丁 JS 代码能够被转化减低，适配了市场占比的浏览器，是不是就已经完成了呢？当然没有。 在 ES6 中出现了 Promise，fetch，以及数组和字符串新的方法，babel 会进行转化吗？会转化成什么呢？肯定不会被转化撒，因为它们都是函数调用，对于 babel 来说就是一个普通的函数调用，只是找不到函数的实现体而已，只是会报错而已。 那么这里也就需要兼容一下，因为新版本的浏览器是认识的，老版本的浏览器是不认识的，那么这里就需要为了兼容了老版浏览器，新部署一个 JS 文件（类似补丁），里面存放了各个函数（promise, fetch）体的实现代码。然后浏览器就能够正常的识别了。 # 参考文章 掘金 - 面试官：说说你在工作中是怎么处理浏览器兼容性","categories":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"（已解决）vue-element-plus-admin打包报错","slug":"node内存问题","date":"2024-10-24T03:51:00.000Z","updated":"2024-10-29T10:17:15.874Z","comments":true,"path":"2024/10/24/node内存问题/","permalink":"https://riddddder.github.io/2024/10/24/node%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 问题描述 在一次使用 vue-element-plus-admin 打包时，出现如下报错: 1FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript # 解决方法 安装依赖工具 1npm install increase-memory-limit --save 1npm install cross-env --save 修改 package.json 如下:[LIMIT 大小自己设置] 123&quot;scripts&quot;: &#123; &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=2048 increase-memory-limit&quot; &#125;, 最后执行就可以打包啦 1npm run fix-memory-limit","categories":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/categories/web/"}],"tags":[{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"}]},{"title":"web学习（一）","slug":"web学习1","date":"2024-01-10T09:51:56.000Z","updated":"2024-10-29T10:26:33.291Z","comments":true,"path":"2024/01/10/web学习1/","permalink":"https://riddddder.github.io/2024/01/10/web%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"# 前端面试整理 (一) js 的数据类型","categories":[{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2022-10-13T11:21:44.000Z","updated":"2024-10-29T10:32:35.430Z","comments":true,"path":"2022/10/13/hello-hexo/","permalink":"https://riddddder.github.io/2022/10/13/hello-hexo/","excerpt":"","text":"# hexo 介绍 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 # 安装前准备 Node.js 12.0 以上版本，下载 git 下载 如果工作需要装了 node 可以安装 nvm 管理多版本 node。 # 安装 安装好 node 后，执行下列命令就可以完成 blog 文件夹初始化（blog 为任意空文件夹名称） 1234npm install -g hexo-clihexo init blogcd blognpm install 然后再执行 1hexo s 就可以看到控制台输出 localhost:4000 就可以在本地浏览器访问啦 # 主题 shoka 在 blog 文件夹 1git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 在_config.yml 中设置 1theme: shoka # 主题 next 在 blog 文件夹 1git clone https://github.com/next-theme/hexo-theme-next ./themes/next 在_config.yml 中设置 1theme: next # 插件 hexo-admin 1$npm install hexo-admin -s 安装好后 locahost:4000/admin 访问 # 文章 # 新建文章 -p, --path: 自定义新文章的路径 -r, --replace: 如果存在同名文章，将其替换 -s, --slug: 文章的 Slug，作为新文章的文件名和发布后的 URL 1hexo new 文章标题 # 发布 # 清除文章缓存 发布前需要清除存在的缓存 db.json 和 public 文件夹下的静态文件。 1hexo clean # 生成静态文件 1hexo g # 部署 部署到 git 上，需要先配置 git 1hexo d # 参考资料 [hexo 官网] https://hexo.io/zh-cn/docs/ [front-matter] https://hexo.io/zh-cn/docs/front-matter.html [shoka-github] https://github.com/amehime/hexo-theme-shoka?tab=readme-ov-file [shoka 文档] https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/ [next 官网] https://theme-next.iissnan.com/","categories":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]}],"categories":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/categories/web/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/categories/hexo/"}],"tags":[{"name":"web","slug":"web","permalink":"https://riddddder.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://riddddder.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"兼容性","slug":"兼容性","permalink":"https://riddddder.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"node","slug":"node","permalink":"https://riddddder.github.io/tags/node/"},{"name":"报错","slug":"报错","permalink":"https://riddddder.github.io/tags/%E6%8A%A5%E9%94%99/"},{"name":"面试","slug":"面试","permalink":"https://riddddder.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"hexo","slug":"hexo","permalink":"https://riddddder.github.io/tags/hexo/"}]}